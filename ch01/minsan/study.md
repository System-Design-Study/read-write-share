# Chapter01: 사용자 수에 따른 규모 확장성

## 단일 서버

복잡한 시스템을 만드는 것에 앞서, 모든 컴포넌트가 단 한 대의 서버에서 실행되는 간단한 시스템부터 설계해본다.

이 시스템에서는 `웹 앱`, `데이터베이스`, `캐시` 등이 전부 서버 한 대에서 실행된다.

![단일서버](https://blog.kakaocdn.net/dn/1DJKx/btsnHRgtcOd/nFRnO3k4nOoreyFFU2aE61/img.png)

> 이미지 출처: https://baebalja.tistory.com/581

사용자의 요청 흐름은 다음과 같을 것이다.

```
1. 도메인 이름을 입력하면 DNS에 전달되고, 해당 도메인의 IP 주소를 반환 받는다.
2. 해당 IP 주소로 HTTP 요청을 전달한다.
3. 요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.
```

## 데이터베이스

사용자가 늘면 서버 하나로는 충분치 않아서 여러 개의 서버를 두어야 한다.  
이번에는 아래의 두 개 서버로 분리해본다.

- `서버1` - 웹/모바일 트래픽 처리 용도
- `서버2` - 데이터베이스용

![데이터베이스](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdOZYzF%2FbtsnHR8DcfT%2F2PkLU2ZYwk6rlfknpkN6cK%2Fimg.png)

> 이미지 출처: https://baebalja.tistory.com/581

이렇게 웹/모바일 트래픽 처리 서버(= `웹 계층`)와 데이터베이스 서버(= `데이터 계층`)를 분리하면, 그 **각각을 독립적으로 확장해 나갈 수 있게** 된다.

### 어떤 데이터베이스를 사용할 것인가?

> 관계형 데이터베이스 vs 비관계형 데이터베이스

`관계형 데이터베이스`는 자료를 테이블과 열, 칼럼으로 표현한다.  
SQL을 사용하여 여러 테이블의 데이터를 관계에 따라 **조인(JOIN)하여 합칠 수 있다.**

`비관계형 데이터베이스`는 아래 네 개의 부류로 나눌 수 있으며, 일반적으로 **조인 연산은 지원하지 않는다.**

- 키-값 저장소
- 그래프 저장소
- 칼럼 저장소
- 문서 저장소

아래와 같은 경우에는 `비관계형 데이터베이스`가 바람직한 선택일 수 있다.

```
[ 비관계형 데이터베이스가 적합한 경우 ]

- 빠른 응답 시간이 요구됨 (= 매우 낮은 latency 요구)
- 다루는 데이터가 비정형이라 관계형 데이터로 표현하기 어려움
- 데이터(JSON, YAML, XML 등)를 직렬화하거나 역직렬화 할 수 있기만 하면 됨
- 아주 많은 양의 데이터를 저장할 필요가 있음
```

#### 응답 시간

관계형 데이터베이스의 경우에는 연산이 복잡해질수록 속도가 느려진다. 또한, 서버 성능에 의존하기 때문에 수평 확장이 비교적 어렵다는 점도 원인으로 볼 수 있을 것 같다.

#### 많은 데이터 처리 요구

비관계형은 분산 아키텍처에 최적화 되어있으며 샤딩, 리플리케이션이 용이하다. 즉, 수평적 확장성이 좋다.

## 수직적 규모 확장 vs 수평적 규모 확장

- `Scale Up`
  - 고사양의 서버로 업그레이드 하여 성능을 개선하는 행위
  - 장애에 대한 자동복구 방안이나 다중화 방안을 제시하지 않음
- `Scale Out`
  - 서버를 추가해서 성능을 개선하는 행위

👉🏻 스케일 업은 한계가 분명 존재하기 때문에, 성능 개선에 있어서 스케일 아웃이 더 권장 된다.

앞서 본 설계에서 사용자는 웹 서버에 바로 연결된다.  
웹 서버가 다운되면 사용자는 웹 사이트에 접속할 수 없다. 또한, **트래픽이 증가**하면서 한계 상황에 도달하면 **응답 속도가 느려지거나 서버 접속이 불가능해질 수도 있다.** 👉🏻 `로드 밸런싱 필요`

### 로드밸런서

로드 밸런싱 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.

![로드밸런서](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcI3WhL%2Fbtsn0EMKyDr%2FrmU8kHTjrjEl8w34bDemz1%2Fimg.png)

> 이미지 출처: https://baebalja.tistory.com/581

클라이언트는 서버에 직접 접근하지 않고, `로드 밸런서`의 **public 주소**를 통해서 `웹 서버`에 접근하게 된다.  
또한, `웹 서버`는 로드 밸런서와 네트워크 상에서의 **private 주소**로 연결되므로 **보안적인 측면에서도 이점**을 얻을 수 있다.

그림처럼 로드 밸런싱 집합에 하나의 웹 서버를 추가하면, 장애를 자동복구하지 못하는 문제가 해소되며 **웹 계층의 가용성이 향상**된다.

- `서버1`이 다운되면 모든 트래픽은 `서버2`로 전송된다. 따라서 웹 사이트 전체가 다운되는 일이 방지된다.
- 웹 사이트로 유입되는 트래픽이 가파르게 증가하면 기존 서버로 트래픽을 감당할 수 없는 시점이 오는데, `로드 밸런서`가 있으므로 이를 대처할 수 있다.
  - `오토 스케일링` 👉🏻 웹 서버 계층에 필요한 만큼 서버를 추가

### 데이터베이스 다중화

하지만 아직 `데이터 계층`은 **장애의 자동복구**나 **다중화**를 지원하는 구성을 갖고 있지 않다.

데이터베이스 다중화에서는 서로 다른 데이터베이스 사이에 관계를 설정한다.

- **master** (주)
  - 데이터 원본을 저장
  - 쓰기 연산 처리 _(`insert`, `delete`, `update` 등은 주 데이터베이스로만 전달되어야 한다)_
- **slave** (부)
  - 데이터 사본을 저장
  - 읽기 연산 처리

![그림1-5](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxzYMl%2FbtsnZXzcdQV%2FGQcwdk9sNmy5ZHBJdPRb20%2Fimg.png)

> 이미지 출처: https://baebalja.tistory.com/582

통상 **읽기 작업의 비중**이 **쓰기 작업의 비중**보다 훨씬 높기 때문에, `부 데이터베이스의 수`가 주 데이터베이스 수보다 **높게 설정**된다.

```
[ 부 데이터베이스 서버 하나가 다운되면? ]

1. 부 서버가 한 대 뿐인데 다운된 경우
- 읽기 연산과 쓰기 연산 모두 주 데이터베이스로 전달된다.
- 또한, 즉시 새로운 부 데이터베이스 서버가 장애 서버를 대체할 것이다.

2. 부 서버가 여러 대인 경우
- 읽기 연산은 나머지 다른 부 데이터베이스 서버들로 분산될 것이다.
- 또한, 즉시 새로운 부 데이터베이스 서버가 장애 서버를 대체할 것이다.

---

[ 주 데이터베이스 서버 하나가 다운되면? ]

- 읽기 연산과 쓰기 연산 모두 부 데이터베이스로 전달된다. (= 해당 서버가 새로운 주 데이터베이스 서버가 된다)
- 또한, 즉시 새로운 부 서버가 추가될 것이다.
```

⭐️ 다만, `주 데이터베이스 서버`가 다운되는 경우에는 **데이터 정합성 문제**에 대한 고려가 필요하다.  
**주 데이터베이스 서버 내용(원본)** 과 **부 데이터베이스 서버 내용(복사본)** 이 서로 일치하지 않을 수 있기 때문이다.

- 👉🏻 **복구 스크립트** 필요

> `다중 마스터`나 `원형 다중화` 방식을 도입하면, 이런 상황에 대처하는 데 도움은 되지만 구성이 훨씬 복잡하다.

#### 로드 밸런서와 데이터베이스 다중화를 고려한 설계

![그림1-6](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcHeZC2%2FbtsnSY7hbOR%2FYtVdT0hEuBv0nGTUzdbqok%2Fimg.png)

> 이미지 출처: https://baebalja.tistory.com/582

이는 아래의 과정으로 동작한다.

```
1. 사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.
2. 사용자는 해당 IP 주소를 사용해 로드밸런서에 접속한다.
3. 로드밸런서는 HTTP 요청을 서버1 또는 서버2로 전달한다.
4-1. 데이터 읽기 연산의 경우, 웹 서버는 부 데이터베이스에 접근한다.
4-2. 데이터 변경 연산의 경우, 웹 서버는 주 데이터베이스에 접근한다.
```

## 캐시

이제 `응답 시간`을 개선할 차례이다.  
응답 시간은 웹 서버에 `캐시`를 붙이고, 정적 콘텐츠를 `CDN`으로 옮기면 개선할 수 있다.

![그림1-7](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnmKfq%2FbtsnZJPbHPw%2FeJLy8TwWkG7eQrB9X12SRK%2Fimg.png)

> 이미지 출처: https://baebalja.tistory.com/582

위의 이미지는 `read-through caching` 전략 예시이다.

### 캐시 사용 유의사항

- 데이터 갱신은 자주 일어나지 않지만, 참조가 빈번한 경우 유용하다.
- 적절한 만료 기한 설정
  - 너무 빠름: 빈번한 DB 접근으로 인한 성능 저하
  - 너무 느림: 일관성 깨짐
- 원본 데이터와 캐싱된 데이터 사이의 일관성 유지
  - `원본 갱신 연산`과 `캐시 갱신 연산`이 **단일 트랜잭션으로 처리되지 않는 경우**에 발생
- 장애 대처
  - 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.
- 여유있는 캐시 메모리 설정
  - 캐시 메모리가 너무 적으면, 액세스 패턴에 따라서 `eviction`이 자주 발생할 수 있음 _(👉🏻 eviction 대상은 `LRU`, `LFU`, `FIFO` 등의 정책에 따라 결정)_

## CDN

> `정적 콘텐츠`(이미지, 비디오, CSS, JS 파일 등)를 전송하는데 쓰이며, 지리적으로 분산된 서버의 네트워크이다.

![그림1-10](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUpyLy%2FbtsnS0c0F7u%2FauPVZpjAPrlplzER7kUSxK%2Fimg.png)

> 이미지 출처: https://baebalja.tistory.com/582

CDN에 저장된 각 파일은 지정된 `TTL`에 따라 관리된다. (👉🏻 TTL이 지나면 삭제)

### CDN 사용 유의사항

- 적절한 TTL 값 설정
- `CDN` 장애에 대한 대처 방안
  - `CDN`에 장애가 발생하여 응답을 받지 못할 때, 클라이언트가 CDN 대신 `원본 서버`에 직접 요청할 수 있도록 구성해야 한다.
- 콘텐츠 무효화
  - CDN 사업자 제공 API 사용
  - **오브젝트 버저닝**
    - 컨텐츠의 다른 버전을 업로드  
      ex) image.png`?v=2`

![그림1-11](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F61wQq%2FbtsnLaUDeDy%2FkMqIkvfryMWgHUiAv9MSF1%2Fimg.png)

> 이미지 출처: https://baebalja.tistory.com/582

> 앞선 설계에 CDN과 캐시를 추가한 모습이다.

위의 설계로 개선된 부분은 다음과 같다.

- `정적 콘텐츠`는 더이상 웹 서버를 통해 서비스하지 않고, `CDN`을 통해 제공한다.
- 캐시가 데이터베이스의 부하를 줄여준다.

## Stateless 웹 계층

> 웹 계층을 수평적으로 확장하기 위해, **상태 정보를 웹 계층에서 제거**하는 것

바람직한 전략은 상태 정보를 `관계형 데이터베이스`나 `NoSQL` 같은 **지속성 저장소**에 보관하는 것이다.

- 만약 상태 정보를 각 서버에 저장한다면, 수평 확장을 하더라도 `클라이언트-서버`가 **1대1로 매핑**되어야 한다.
  - 즉, **같은 클라이언트의 요청을 항상 같은 서버로 전송해야** 하며, 로드 밸런싱도 무의미해진다.

_ex) 유저의 세션 정보를 `Redis`에 저장_

### 무상태 아키텍처

앞선 설계에 무상태 웹 계층을 갖도록 변경한 것이다.

- 각 서버가 무상태로 존재하기 위해서, **상태 값을 저장하는 별도의 데이터베이스(NoSQL)를 분리한 것**을 확인할 수 있다.

![그림1-14](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcU1qQB%2Fbtsn7xnoFHx%2F1fm8i474hja8YUOOWMjaK1%2Fimg.png)

> 이미지 출처: https://baebalja.tistory.com/584

👉🏻 상태 저장 DB를 `NoSQL`로 설정한 이유는 비관계형 데이터베이스가 **규모 확장이 더 간편하기 때문**이다.

## 데이터 센터

서비스를 **전 세계** 어디에서도 쾌적하게 사용할 수 있도록 하기 위해서는 **여러 데이터 센터를 지원하는 것**이 필수적이다.

### 지리적 라우팅(geoDNS-routing)

> 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내된다.

## 메시지 큐

> 메시지의 `무손실` _(= 소비자가 꺼낼 때까지 안전하게 보관)_ 을 보장하는, `비동기 통신`을 지원하는 컴포넌트이다.

![그림1-17](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdHXi9M%2Fbtsn8k8WOsN%2FNLijiLNT3SWUCmCoegGLWk%2Fimg.png)

> 이미지 출처: https://baebalja.tistory.com/584

메시지 큐를 이용하면 `서비스 또는 서버 간의 결합이 느슨`해진다.

- **규모 확장성**이 보장되어야 하는 안정적인 애플리케이션을 구성하기 좋음

## 로그, 메트릭 그리고 자동화

### 로그

- 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 로그를 관리할 수 있다.

### 메트릭

> `prometheus`, `grafana`로 쿠버네티스 노드 모니터링 시스템 구축했던 것과 비슷한 맥락인 것 같다.

- 메트릭을 잘 수집하면 시스템의 현황을 파악할 수 있다.

### 자동화

- 빌드, 테스트, 배포 등의 절차를 자동화하여 개발 생산성을 향상시킬 수 있다.

## 메시지 큐, 로그, 메트릭, 자동화 등을 반영한 설계안

![그림1-19](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLROdb%2Fbtsn1afLGjL%2F9nZ1V3r0NhKToQXBFkVrZ0%2Fimg.png)

> 이미지 출처: https://baebalja.tistory.com/584

- 메시지 큐는 각 컴포넌트가 느슨히 결합될 수 있도록 하고, 결함에 대한 내성을 높인다.
  - 다른 서버에 장애가 발생하더라도, 이에 영향을 받지 않는다.

## 데이터베이스의 규모 확장

### 샤딩(sharding)

> 데이터베이스의 수평적 확장을 샤딩이라고 부르며, 더 많은 데이터베이스 서버를 추가함으로써 성능을 향상시킨다.

대규모 데이터베이스를 `샤드`라는 작은 단위로 분할하는 기술을 의미한다.

#### 샤드

모든 샤드는 **같은 스키마를 공유**하지만, 샤드에 보관되는 데이터 사이에는 **중복이 존재하지 않는다.**

- 👉🏻 해시 테이블과 비슷하다.

![그림1-21](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F63P2H%2Fbtsn7uxtFmS%2FQFP2FFApxek2bNrg1W1gU1%2Fimg.png)

> 이미지 출처: https://baebalja.tistory.com/584

위 그림에서는 `user_id`를 `샤딩 키` 값으로 사용했다.  
이러한 샤딩 키는 하나 이상의 칼럼으로 구성된다.

**hash set/map**과 마찬가지로, **데이터를 고르게 분할할 수 있도록** 키 값과 알고리즘을 설정하는 것이 중요하다.

### 샤딩 유의사항

#### 1. 데이터의 재 샤딩(resharding)

샤드 소진이 발생할 때 데이터를 재 샤딩해야 하는 상황이 발생한다.
아래는 샤드 소진이 발생하는 경우이다.

```
- 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때
- 샤드 간 데이터 분포가 균등하지 못해, 특정 샤드에 할당된 공간 소모가 빨리 진행될 때
```

#### 2. 유명인사 문제 (= 핫스팟 키 문제)

특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제이다.  
👉🏻 이는 각 데이터의 참조 빈도수에 의해 발생하는 문제이다.

이를 해결하려면 각 샤드에 하나씩 참조가 빈번한 데이터를 적재해야 할 수도 있고, 더 잘게 쪼개야 할 수도 있다.

#### 3. 조인과 비정규화

하나의 데이터베이스를 여러 개의 샤드 서버로 쪼개면, 여러 샤드에 걸친 데이터를 조인하기 어려워진다.

이를 해결하는 한 가지 방법은 `데이터베이스를 비정규화` 하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것이다.

> **_비정규화_**  
> join 연산이 과도할 경우, 비정규화를 통해 성능을 개선할 수 있다.  
> 다만, 비정규화는 데이터 수정에 매우 취약하기 때문에 `읽기 연산`이 주로 발생하는 지점에서 사용하는 것이 좋다.

## 데이터베이스 샤딩 적용 설계

![그림1-23](https://bytebytego.com/_next/image?url=%2Fimages%2Fcourses%2Fsystem-design-interview%2Fscale-from-zero-to-millions-of-users%2Ffigure-1-23-3IYFN6Q6.png&w=1200&q=75)

> 이미지 출처: https://bytebytego.com/courses/system-design-interview/scale-from-zero-to-millions-of-users

```
1. CDN
- 정적 콘텐츠 캐싱

2. NoSQL
- 사용자 상태 값(세션 등)을 저장
    👉🏻 어느 웹 서버에서도 동일한 값을 읽을 수 있음
    👉🏻 stateless 서버 구축 및 웹 서버 다중화 가능하게 함

3. 데이터베이스
- master/slave 데이터베이스 분리
    👉🏻 데이터베이스 응답 지연 시간 감소 (읽기 연산은 여러 대의 부 데이터베이스로, 쓰기 연산은 주 데이터베이스로)
    👉🏻 부하로 인한 데이터베이스 서버 장애 방지
    👉🏻 장애 발생시 중단 없이 복구 가능
- 샤딩
    👉🏻 데이터베이스 수평적 확장을 통해 과부하 방지

4. 캐시
- 데이터베이스의 일부 데이터를 캐시에 적재
    👉🏻 웹 서버가 데이터베이스에 빠르게 접근 가능

5. 작업 서버
- 서비스를 별도의 서버로 운영
    👉🏻 웹 서버와의 의존성 감소
```

## 정리

- **웹 계층**은 `무상태 계층`으로
- **모든 계층에** `다중화` 도입
- 가능한 많은 데이터를 **캐시**할 것
- 여러 **데이터 센터**를 지원할 것
- **정적 콘텐츠**는 `CDN`을 통해 서비스 할 것
- **데이터 계층**은 `샤딩`을 통해 그 규모를 확장할 것
- 각 계층은 **독립적 서비스로 분할**할 것
- 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것
